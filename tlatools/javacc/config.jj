/*****************************************************************************
* This grammar file config.jj specifies the parsing of the string in         *
* defaultConfig. Alternatively the content of a file named config.src in the *
* current directory can also be used.                                        *
*                                                                            *
* Generating the parser is done by:                                          *
*   javacc -OUTPUT_DIRECTORY=config config.jj                                *
*                                                                            *
* Inserting the parser into the tlatools is done by:                         *
*   cp -r config/* ../src/tla2sany/configuration/                            *
*                                                                            *
* Changes to the generated code should always be done by changing this file, *
* generating a new parser in a fresh directory and inserting the new parser  *
* into tlatools. The commit should contain the changes in this file and the  *
* changes in the tlatoos source code.                                        *
******************************************************************************/

/*
            LOOKAHEAD              (default 1)
            CHOICE_AMBIGUITY_CHECK (default 2)
            OTHER_AMBIGUITY_CHECK  (default 1)

            STATIC                 (default true)
            DEBUG_PARSER           (default true)
            DEBUG_LOOKAHEAD        (default false)
            DEBUG_TOKEN_MANAGER    (default false)
            ERROR_REPORTING        (default true)
            JAVA_UNICODE_ESCAPE    (default false)
            UNICODE_INPUT          (default false)
            IGNORE_CASE            (default false)
            COMMON_TOKEN_ACTION    (default false)
            USER_TOKEN_MANAGER     (default false)
            USER_CHAR_STREAM       (default false)
            BUILD_PARSER           (default true)
            BUILD_TOKEN_MANAGER    (default true)
            SANITY_CHECK           (default true)
            FORCE_LA_CHECK         (default false)
*/
options {
  LOOKAHEAD = 1;
  JAVA_UNICODE_ESCAPE = false; /* disable processing of \\u */
  UNICODE_INPUT = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  STATIC = true;
}

PARSER_BEGIN(Configuration)

/*****************************************************************************
* WARNING: Do not touch this generated code directly! Refer to config.jj     *
******************************************************************************/
package tla2sany.configuration;

import java.io.File;

import tla2sany.parser.Operator;
import tla2sany.parser.Operators;
import tla2sany.parser.SyntaxTreeNode;
import tla2sany.semantic.AbortException;
import tla2sany.semantic.Context;
import tla2sany.semantic.Errors;
import tla2sany.semantic.FormalParamNode;
import tla2sany.semantic.OpDefNode;
import tla2sany.st.Location;
import util.ToolIO;
import util.UniqueString;

public final class Configuration {

  private static final String defaultConfig =
    /***********************************************************************
    * This is used in config/Configuration.java to create Operator         *
    * objects for each operator, which are put in the hashtable            *
    * Operators.BuiltinTable.                                              *
    ***********************************************************************/
    "operator [ 160 160 Left postfix \n" +
    "operator . 170 170 Left infix \n" +
    "operator ' 150 150 None postfix\n" +
    "operator ^ 140 140 None infix\n" +  // None, verified.
    "operator / 130 130 None infix\n" +
    "operator * 130 130 Left infix\n" +
    "operator - 110 110 Left infix\n" +
    "operator -. 120 120 None prefix\n" +
    "operator + 100 100 Left infix\n" +
    "operator = 50 50 None infix\n" +
    "operator \\lnot 40 40 Left prefix \n" +
    "synonym  ~ \\lnot\n" +
    "synonym \\neg \\lnot\n" +
    "operator \\land 30 30 Left infix\n" +
    "synonym  /\\ \\land\n" +
    "operator \\lor 30 30 Left infix\n" +
    "synonym  \\/ \\lor\n" +
    "operator ~> 20 20 None infix\n" +
    "operator => 10 10  None infix\n" +
    //\n" +
    "operator [] 40 150 None prefix \n" +
    "operator <> 40 150 None prefix \n" +
    "operator ENABLED 40 150 None prefix \n" +
    "operator UNCHANGED 40 150 None prefix \n" +
    "operator SUBSET 100 130 None prefix \n" +
    "operator UNION 100 130 None prefix \n" +
    "operator DOMAIN 100 130 None prefix \n" +
    //\n" +
    "operator ^+ 150 150 None postfix\n" +
    "operator ^* 150 150 None postfix\n" +
    "operator ^# 150 150 None postfix\n" +
    //\n" +
    "operator \\cdot 50 140  Left infix\n" +
    //\n" +
    "operator \\equiv 20 20  None infix\n" +
    "synonym <=> \\equiv\n" +
    //\n" +
    "operator -+-> 20 20 None infix\n" +
    "operator /= 50 50 None infix\n" +
    "synonym # /=\n" +
    "operator \\subseteq 50 50 None infix\n" +
    "operator \\in 50 50 None infix\n" +
    "operator \\notin 50 50 None infix\n" +
    "operator < 50 50 None infix\n" +
    "operator \\leq 50 50 None infix\n" +
    "synonym <= \\leq\n" +
    "synonym =< \\leq\n" +
    "operator > 50 50 None infix\n" +
    "operator \\geq 50 50 None infix\n" +
    "synonym >= \\geq\n" +
    //\n" +
    "operator \\times 100 130 Left nfix\n" +
    "synonym  \\X \\times\n" +
    "operator \\ 80 80 None infix\n" +
    "operator \\intersect 80 80 Left infix\n" +
    "synonym \\cap \\intersect \n" +
    "operator \\union 80 80 Left infix\n" +
    "synonym \\cup \\union\n" +
    //\n" +
    "operator ... 90 90 None infix\n" +
    "operator .. 90 90 None infix\n" +
    "operator | 100 110 Left infix\n" +
    "operator || 100 110 Left infix\n" +
    "operator && 130 130 Left infix\n" +
    "operator & 130 130 Left infix\n" +
    "operator $$ 90 130 Left infix\n" +
    "operator $ 90 130 Left infix\n" +
    "operator ?? 90 130 Left infix\n" +
    //"operator ? 90 130 Left infix\n" +  // Removed requested by Leslie (16 Feb. 01)
    "operator %% 100 110 Left infix\n" +
    "operator % 100 110 None infix\n" +
    "synonym \\mod %\n" +
    "operator ## 90 130 Left infix\n" +
    "operator ++ 100 100 Left infix\n" +
    "operator -- 110 110 Left infix\n" +
    "operator ** 130 130 Left infix\n" +
    "operator // 130 130 None infix\n" +
    "operator ^^ 140 140 None infix\n" +
    "operator @@ 60 60 Left infix\n" +
    "operator !! 90 130 None infix\n" +
    "operator |- 50 50 None infix\n" +
    "operator |= 50 50 None infix\n" +
    "operator -| 50 50 None infix\n" +
    "operator =| 50 50 None infix\n" +
    "operator <: 70 70 None infix\n" +
    "operator :> 70 70 None infix\n" +
    "operator := 50 50 None infix\n" +
    "operator ::= 50 50 None infix\n" +
// \n" +
    "operator \\oplus 100 100 Left infix\n" +
    "synonym (+) \\oplus\n" +
    "operator \\ominus 110 110 Left infix\n" +
    "synonym (-) \\ominus\n" +
    "operator \\odot 130 130 Left infix\n" +
    "synonym (.) \\odot\n" +
    "operator \\oslash 130 130 None infix\n" +
    "synonym (/) \\oslash\n" +
    "operator \\otimes 130 130 Left infix\n" +
    "synonym (\\X) \\otimes\n" +
// \n" +
    "operator \\uplus 90 130 Left infix\n" +
    "operator \\sqcap 90 130 Left infix\n" +
    "operator \\sqcup 90 130 Left infix\n" +
    "operator \\div 130 130 None infix\n" +
    "operator \\wr 90 140 None infix\n" +
    "operator \\star 130 130 Left infix\n" +
    "operator \\o 130 130 Left infix\n" +
    "synonym  \\circ \\o \n" +
    "operator \\bigcirc 130 130 Left infix\n" +
    "operator \\bullet 130 130 Left infix\n" +
    "operator \\prec 50 50 None infix\n" +
    "operator \\succ 50 50 None infix\n" +
    "operator \\preceq 50 50 None infix\n" +
    "operator \\succeq 50 50 None infix\n" +
    "operator \\sim 50 50 None infix\n" +
    "operator \\simeq 50 50 None infix\n" +
    "operator \\ll 50 50 None infix\n" +
    "operator \\gg 50 50 None infix\n" +
    "operator \\asymp 50 50 None infix\n" +
    "operator \\subset 50 50 None infix\n" + // subseteq is builtin
    "operator \\supset 50 50 None infix\n" +
    "operator \\supseteq 50 50 None infix\n" +
    "operator \\approx 50 50 None infix\n" +
    "operator \\cong 50 50 None infix\n" +
    "operator \\sqsubset 50 50 None infix\n" +
    "operator \\sqsubseteq 50 50 None infix\n" +
    "operator \\sqsupset 50 50 None infix\n" +
    "operator \\sqsupseteq 50 50 None infix\n" +
    "operator \\doteq 50 50 None infix\n" +
    "operator \\propto 50 50 None infix\n" +
    //\n" +
    "builtin STRING    $$_string     constant\n" +
    "builtin FALSE     $$_false      constant\n" +
    "builtin TRUE      $$_true       constant\n" +
    "builtin BOOLEAN   $$_boolean    constant\n" +
    //\n" +
    "builtin =         $$_equal        infix\n" +
    "builtin /=        $$_notEqual     infix\n" +
    //\n" +
    "builtin .         $$_dot          infix\n" +
    "builtin '         $$_prime        postfix\n" +
    "builtin \\lnot     $$_not          prefix\n" +
    "builtin \\neg      $$_neg          prefix\n" +
    "builtin \\land     $$_and          infix\n" +
    "builtin \\lor      $$_or           infix\n" +
    "builtin \\equiv    $$_equivalent   infix\n" +
    "builtin =>        $$_implies      infix\n" +
    //\n" +
    "builtin SUBSET     $$_subset      prefix\n" +
    "builtin UNION      $$_union       prefix\n" +
    "builtin DOMAIN     $$_domain      prefix\n" +
    "builtin \\subseteq  $$_subseteq    infix \n" +
    "builtin \\in        $$_in          infix \n" +
    "builtin \\notin     $$_notin       infix \n" +
    "builtin \\          $$_setdiff     infix \n" +
    "builtin \\intersect $$_setinter    infix \n" +
    "builtin \\union     $$_setunion    infix \n" +
    "builtin \\times     $$_times       infix \n" +
    //\n" +
    "builtin ~>         $$_leadsTo     infix \n" +
    "builtin []         $$_box         prefix\n" +
    "builtin <>         $$_diamond     prefix\n" +
    "builtin ENABLED    $$_enabled     prefix\n" +
    "builtin UNCHANGED  $$_unchanged   prefix\n" +
    "builtin \\cdot     $$_cdot        infix \n" +
    "builtin -+->       $$_arrow       infix \n" +
//
    "builtin $AngleAct                $$_null   2\n" +
    "builtin $BoundedChoose           $$_null  -1\n" +
    "builtin $BoundedExists           $$_null  -1\n" +
    "builtin $BoundedForall           $$_null  -1\n" +
    "builtin $CartesianProd           $$_null  -1\n" +
    "builtin $Case                    $$_null  -1\n" +
    "builtin $ConjList                $$_null  -1\n" +
    "builtin $DisjList                $$_null  -1\n" +
    "builtin $Except                  $$_null  -1\n" + // arity corrected from 1 to -1 DRJ 20 Nov '00
    "builtin $FcnApply                $$_null   2\n" +
    "builtin $FcnConstructor          $$_null  -1\n" +
    "builtin $IfThenElse              $$_null   3\n" +
    "builtin $NonRecursiveFcnSpec     $$_null   1\n" +
    "builtin $Pair                    $$_null   2\n" +
    "builtin $RcdConstructor          $$_null  -1\n" +
    "builtin $RcdSelect               $$_null   2\n" +
    "builtin $RecursiveFcnSpec        $$_null   1\n" +
    "builtin $Seq                     $$_null  -1\n" +
    "builtin $SetEnumerate            $$_null  -1\n" +
    "builtin $SetOfAll                $$_null  -1\n" +
    "builtin $SetOfFcns               $$_null  -1\n" +
    "builtin $SetOfRcds               $$_null  -1\n" + // Added by DRJ 1 Oct '00
    "builtin $SF                      $$_null   2\n" +
    "builtin $SquareAct               $$_null   2\n" +
    "builtin $SubsetOf                $$_null   1\n" +
    "builtin $TemporalExists          $$_null   1\n" +
    "builtin $TemporalForall          $$_null   1\n" +
    "builtin $TemporalWhile           $$_null   2\n" +
    "builtin $Tuple                   $$_null  -1\n" +
    "builtin $UnboundedChoose         $$_null   1\n" +
    "builtin $UnboundedExists         $$_null   1\n" +
    "builtin $UnboundedForall         $$_null   1\n" +
    "builtin $WF                      $$_null   2\n"   +
    "builtin $Nop                     $$_null   1\n"   +
    "builtin $Qed                     $$_null   0\n"   +
    "builtin $Pfcase                  $$_null   1\n"   +
    "builtin $Have                    $$_null   1\n"   +
    "builtin $Take                    $$_null   1\n"   +
    "builtin $Pick                    $$_null   1\n"   +
    "builtin $Witness                 $$_null   -1\n"  +

    /***********************************************************************
    * $Suffices added by LL 16 Feb 2009.                                   *
    ***********************************************************************/
    "builtin $Suffices                $$_null   1\n"
  ;

  private static Errors errors;
  private static java.io.Reader input;

  public static void displayDefinitions() {
    ToolIO.out.println( defaultConfig );
  }

  public static void load(Errors errs) throws AbortException {
    /***********************************************************************
    * Called from drivers/SANY.java                                        *
    ***********************************************************************/
    Configuration Parser;
    try {
      errors = errs;
      File source = new File( "config.src" );
      String origin;

      if ( source.exists() ) {
//      java.io.OutputStream output;
        input = new java.io.FileReader( source );
        origin = " from local config.src file.";
      } else {
        input = new java.io.StringReader( defaultConfig );
        origin = " from defaults.";
      }
      Parser = new Configuration( input );

      try {
        Parser.ConfigurationUnit();
//      Operators.printTable();
      } catch (ParseException e) {
        errors.addAbort(Location.nullLoc,"\nConfiguration Parser:  Encountered errors during parse.  "
                        + e.getMessage(),true );
      }

    } catch (java.io.FileNotFoundException e) {
      errors.addAbort(Location.nullLoc,"File not found.\n" + e,true);
    }
  }

}
PARSER_END(Configuration)

SKIP : { " " | "\t" | "\n" }

MORE : {
  < SINGLE_LINE: "(*" >     : IN_COMMENT
}

<IN_COMMENT> SPECIAL_TOKEN: {
   "*)" : DEFAULT
}

<IN_COMMENT> MORE: {
  < ~[] >
}

TOKEN : {
  < CONSTANT : ( "CONSTANT" | "constant" ) >
| < OPERATOR : ( "OPERATOR" | "operator" | "op" | "OP" ) >
| < INFIX    : (   "INFIX" | "infix" ) >
| < POSTFIX  : ( "POSTFIX" | "postfix" ) >
| < PREFIX   : (  "PREFIX" | "prefix" ) >
| < NFIX     : ( "NFIX" | "nfix" ) >
| < NOTOP    : (  "notAnOp" | "NoOP" | "NOOP" | "NOTANOP" ) >
| < SYNONYM  : ( "SYNONYM" | "synonym" ) >
| < LEFTASSOC  : ( "left" | "LEFT" | "Left" ) >
| < RIGHTASSOC : ( "right" | "RIGHT" | "Right" ) >
| < NOASSOC    : ( "none" | "NONE" | "None" ) >
| < BUILTIN    : ( "builtin" | "BUILTIN"  | "Built-In" ) >
}

TOKEN : {
  < #OPCHAR : [ "(", "[", "{", ")", "]", "}", "+", "-",  "/", "^", "*", "|", "!", "?", "#", "$", "%", "&", "@", "~", "=" , "." , ":" , "," , "\\" , "_", ">" , "<", "'"  ]  >
| < #LETTER: ["a"-"z", "A"-"Z"] >
| < OPID : (<OPCHAR>)+ | ( ("\\")? (<LETTER>)+ ) | "(\\X)" | ("$") (<LETTER>)+  >
| < NUMBER : ("-")? ["1"-"9"] (["0"-"9"])* | "0" >
| < RESTRICTED : ( "$$_" (<LETTER>)+ ) >
}

void
ConfigurationUnit() throws AbortException : { }{
  (OpDefinition()) *
}

void
OpDefinition() throws AbortException : {
  Token t; }{
  ( <OPERATOR> (t = <OPID>) { /* ToolIO.out.println( t.image ); */ } ( OpBody(t.image) | OpNull(t.image) ) )
  | OpSynonym()
  | OpBuiltin()
}

void
OpBody( String s ) : {
 Token t;
 int kind, assoc;
 int low, high; }{
 t = <NUMBER> { low = Integer.parseInt( t.image ); }
 t = <NUMBER> { high = Integer.parseInt( t.image ); }
 ( ( <LEFTASSOC> { assoc = Operators.assocLeft; } )
 | ( <RIGHTASSOC> { assoc = Operators.assocRight; } )
 | ( <NOASSOC> { assoc = Operators.assocNone; } )
 )
 ( ( <INFIX> { kind = Operators.infix; } )
 | ( <PREFIX> { kind = Operators.prefix; } )
 | ( <POSTFIX> { kind = Operators.postfix; } )
 | ( <NFIX> { kind = Operators.nfix; } )
 ) { t = null; }
 [t = <OPID>]
 {
   Operator op;
   if ( t == null ) {
     op = new Operator( UniqueString.uniqueStringOf(s), low, high, assoc, kind );
   } else {
     op = new Operator( UniqueString.uniqueStringOf(t.image), low, high, assoc, kind );
   }
   Operators.addOperator( UniqueString.uniqueStringOf(s), op );
 }
}

void
OpSynonym() : {
  Token t1, t2; }{
  <SYNONYM> t1 = <OPID> t2 = <OPID> {
    Operators.addSynonym( UniqueString.uniqueStringOf(t1.image),
                          UniqueString.uniqueStringOf(t2.image) );
 }
}

void
OpNull( String s ) : {
    Token t; }{
  <NOTOP>
}

void
OpBuiltin() throws AbortException : {
  Token t;
  String external, internal;
  UniqueString us;
//  Signature sig;
}{
  <BUILTIN>
  t = <OPID> {
    external = t.image;
    us = UniqueString.uniqueStringOf( external );
  }
  t = <RESTRICTED> {
    internal = t.image;
  }
//  sig = Signature()
 (    <INFIX> {
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 2,
                        new FormalParamNode[2], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
     }
 |    <PREFIX> {
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 1,
                        new FormalParamNode[1], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
    }
 |    <POSTFIX> {
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 1,
                        new FormalParamNode[1], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
   }
 | <CONSTANT> {
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 0,
                        new FormalParamNode[0], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
   }
 | t = <NUMBER> {
      int n = Integer.parseInt( t.image );
      FormalParamNode fpn[] = null;
      if ( n != -1 ) fpn = new FormalParamNode[ n ];
      Context.addGlobalSymbol(us,
                        new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, n,
                                      fpn, false, null, null, null, new SyntaxTreeNode(us)),
                                      errors);
   }
 )
  { }
}

/*
new OpDefNode( tla2sany.semantic.ASTConstants.BuiltInKind, {null,null}, false );

Signature
Signature() : {
  Signature sig = new Signature(); } {
  ( ( <OPID> <OPERATOR> { sig.addPar(); sig.addId(); }
      [ <OPID> {sig.addPar(); } ]
    ) |
    ( <OPERATOR> { sig.addId(); } // op _ op ( _ + )
      ( (LOOKAHEAD ( { getToken(1).image.equals("_") } )
          <OPID> { sig.addPar(); }
        ) |
        (LOOKAHEAD ( { getToken(1).image.equals("(") } )
          <OPID> { sig.addLBR(); }
          (
            (LOOKAHEAD ( { getToken(1).image.equals( "_" ) } ) <OPID> { getToken(1).image.equals("_"); } )
            | (LOOKAHEAD ( { getToken(1).image.equals( "__" ) } ) <OPID> { getToken(1).image.equals("__"); } )
          )+
          ( LOOKAHEAD ( { getToken(1).image.equals( ")" ) } )
            <OPID> {sig.addRBR(); }
          )
        )
      )
    )
  ) { return sig; }
}

*/
