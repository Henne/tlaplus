/* Generated By:JavaCC: Do not edit this line. Configuration.java */
/*****************************************************************************
* WARNING: Do not touch this generated code directly! Refer to config.jj     *
******************************************************************************/
package tla2sany.configuration;

import java.io.File;

import tla2sany.parser.Operator;
import tla2sany.parser.Operators;
import tla2sany.parser.SyntaxTreeNode;
import tla2sany.semantic.AbortException;
import tla2sany.semantic.Context;
import tla2sany.semantic.Errors;
import tla2sany.semantic.FormalParamNode;
import tla2sany.semantic.OpDefNode;
import tla2sany.st.Location;
import util.ToolIO;
import util.UniqueString;

public final class Configuration implements ConfigurationConstants {

  private static final String defaultConfig =
    /***********************************************************************
    * This is used in config/Configuration.java to create Operator         *
    * objects for each operator, which are put in the hashtable            *
    * Operators.BuiltinTable.                                              *
    ***********************************************************************/
    "operator [ 160 160 Left postfix \n" +
    "operator . 170 170 Left infix \n" +
    "operator ' 150 150 None postfix\n" +
    "operator ^ 140 140 None infix\n" +  // None, verified.
    "operator / 130 130 None infix\n" +
    "operator * 130 130 Left infix\n" +
    "operator - 110 110 Left infix\n" +
    "operator -. 120 120 None prefix\n" +
    "operator + 100 100 Left infix\n" +
    "operator = 50 50 None infix\n" +
    "operator \\lnot 40 40 Left prefix \n" +
    "synonym  ~ \\lnot\n" +
    "synonym \\neg \\lnot\n" +
    "operator \\land 30 30 Left infix\n" +
    "synonym  /\\ \\land\n" +
    "operator \\lor 30 30 Left infix\n" +
    "synonym  \\/ \\lor\n" +
    "operator ~> 20 20 None infix\n" +
    "operator => 10 10  None infix\n" +
    //\n" +
    "operator [] 40 150 None prefix \n" +
    "operator <> 40 150 None prefix \n" +
    "operator ENABLED 40 150 None prefix \n" +
    "operator UNCHANGED 40 150 None prefix \n" +
    "operator SUBSET 100 130 None prefix \n" +
    "operator UNION 100 130 None prefix \n" +
    "operator DOMAIN 100 130 None prefix \n" +
    //\n" +
    "operator ^+ 150 150 None postfix\n" +
    "operator ^* 150 150 None postfix\n" +
    "operator ^# 150 150 None postfix\n" +
    //\n" +
    "operator \\cdot 50 140  Left infix\n" +
    //\n" +
    "operator \\equiv 20 20  None infix\n" +
    "synonym <=> \\equiv\n" +
    //\n" +
    "operator -+-> 20 20 None infix\n" +
    "operator /= 50 50 None infix\n" +
    "synonym # /=\n" +
    "operator \\subseteq 50 50 None infix\n" +
    "operator \\in 50 50 None infix\n" +
    "operator \\notin 50 50 None infix\n" +
    "operator < 50 50 None infix\n" +
    "operator \\leq 50 50 None infix\n" +
    "synonym <= \\leq\n" +
    "synonym =< \\leq\n" +
    "operator > 50 50 None infix\n" +
    "operator \\geq 50 50 None infix\n" +
    "synonym >= \\geq\n" +
    //\n" +
    "operator \\times 100 130 Left nfix\n" +
    "synonym  \\X \\times\n" +
    "operator \\ 80 80 None infix\n" +
    "operator \\intersect 80 80 Left infix\n" +
    "synonym \\cap \\intersect \n" +
    "operator \\union 80 80 Left infix\n" +
    "synonym \\cup \\union\n" +
    //\n" +
    "operator ... 90 90 None infix\n" +
    "operator .. 90 90 None infix\n" +
    "operator | 100 110 Left infix\n" +
    "operator || 100 110 Left infix\n" +
    "operator && 130 130 Left infix\n" +
    "operator & 130 130 Left infix\n" +
    "operator $$ 90 130 Left infix\n" +
    "operator $ 90 130 Left infix\n" +
    "operator ?? 90 130 Left infix\n" +
    //"operator ? 90 130 Left infix\n" +  // Removed requested by Leslie (16 Feb. 01)
    "operator %% 100 110 Left infix\n" +
    "operator % 100 110 None infix\n" +
    "synonym \\mod %\n" +
    "operator ## 90 130 Left infix\n" +
    "operator ++ 100 100 Left infix\n" +
    "operator -- 110 110 Left infix\n" +
    "operator ** 130 130 Left infix\n" +
    "operator // 130 130 None infix\n" +
    "operator ^^ 140 140 None infix\n" +
    "operator @@ 60 60 Left infix\n" +
    "operator !! 90 130 None infix\n" +
    "operator |- 50 50 None infix\n" +
    "operator |= 50 50 None infix\n" +
    "operator -| 50 50 None infix\n" +
    "operator =| 50 50 None infix\n" +
    "operator <: 70 70 None infix\n" +
    "operator :> 70 70 None infix\n" +
    "operator := 50 50 None infix\n" +
    "operator ::= 50 50 None infix\n" +
// \n" +
    "operator \\oplus 100 100 Left infix\n" +
    "synonym (+) \\oplus\n" +
    "operator \\ominus 110 110 Left infix\n" +
    "synonym (-) \\ominus\n" +
    "operator \\odot 130 130 Left infix\n" +
    "synonym (.) \\odot\n" +
    "operator \\oslash 130 130 None infix\n" +
    "synonym (/) \\oslash\n" +
    "operator \\otimes 130 130 Left infix\n" +
    "synonym (\\X) \\otimes\n" +
// \n" +
    "operator \\uplus 90 130 Left infix\n" +
    "operator \\sqcap 90 130 Left infix\n" +
    "operator \\sqcup 90 130 Left infix\n" +
    "operator \\div 130 130 None infix\n" +
    "operator \\wr 90 140 None infix\n" +
    "operator \\star 130 130 Left infix\n" +
    "operator \\o 130 130 Left infix\n" +
    "synonym  \\circ \\o \n" +
    "operator \\bigcirc 130 130 Left infix\n" +
    "operator \\bullet 130 130 Left infix\n" +
    "operator \\prec 50 50 None infix\n" +
    "operator \\succ 50 50 None infix\n" +
    "operator \\preceq 50 50 None infix\n" +
    "operator \\succeq 50 50 None infix\n" +
    "operator \\sim 50 50 None infix\n" +
    "operator \\simeq 50 50 None infix\n" +
    "operator \\ll 50 50 None infix\n" +
    "operator \\gg 50 50 None infix\n" +
    "operator \\asymp 50 50 None infix\n" +
    "operator \\subset 50 50 None infix\n" + // subseteq is builtin
    "operator \\supset 50 50 None infix\n" +
    "operator \\supseteq 50 50 None infix\n" +
    "operator \\approx 50 50 None infix\n" +
    "operator \\cong 50 50 None infix\n" +
    "operator \\sqsubset 50 50 None infix\n" +
    "operator \\sqsubseteq 50 50 None infix\n" +
    "operator \\sqsupset 50 50 None infix\n" +
    "operator \\sqsupseteq 50 50 None infix\n" +
    "operator \\doteq 50 50 None infix\n" +
    "operator \\propto 50 50 None infix\n" +
    //\n" +
    "builtin STRING    $$_string     constant\n" +
    "builtin FALSE     $$_false      constant\n" +
    "builtin TRUE      $$_true       constant\n" +
    "builtin BOOLEAN   $$_boolean    constant\n" +
    //\n" +
    "builtin =         $$_equal        infix\n" +
    "builtin /=        $$_notEqual     infix\n" +
    //\n" +
    "builtin .         $$_dot          infix\n" +
    "builtin '         $$_prime        postfix\n" +
    "builtin \\lnot     $$_not          prefix\n" +
    "builtin \\neg      $$_neg          prefix\n" +
    "builtin \\land     $$_and          infix\n" +
    "builtin \\lor      $$_or           infix\n" +
    "builtin \\equiv    $$_equivalent   infix\n" +
    "builtin =>        $$_implies      infix\n" +
    //\n" +
    "builtin SUBSET     $$_subset      prefix\n" +
    "builtin UNION      $$_union       prefix\n" +
    "builtin DOMAIN     $$_domain      prefix\n" +
    "builtin \\subseteq  $$_subseteq    infix \n" +
    "builtin \\in        $$_in          infix \n" +
    "builtin \\notin     $$_notin       infix \n" +
    "builtin \\          $$_setdiff     infix \n" +
    "builtin \\intersect $$_setinter    infix \n" +
    "builtin \\union     $$_setunion    infix \n" +
    "builtin \\times     $$_times       infix \n" +
    //\n" +
    "builtin ~>         $$_leadsTo     infix \n" +
    "builtin []         $$_box         prefix\n" +
    "builtin <>         $$_diamond     prefix\n" +
    "builtin ENABLED    $$_enabled     prefix\n" +
    "builtin UNCHANGED  $$_unchanged   prefix\n" +
    "builtin \\cdot     $$_cdot        infix \n" +
    "builtin -+->       $$_arrow       infix \n" +
//
    "builtin $AngleAct                $$_null   2\n" +
    "builtin $BoundedChoose           $$_null  -1\n" +
    "builtin $BoundedExists           $$_null  -1\n" +
    "builtin $BoundedForall           $$_null  -1\n" +
    "builtin $CartesianProd           $$_null  -1\n" +
    "builtin $Case                    $$_null  -1\n" +
    "builtin $ConjList                $$_null  -1\n" +
    "builtin $DisjList                $$_null  -1\n" +
    "builtin $Except                  $$_null  -1\n" + // arity corrected from 1 to -1 DRJ 20 Nov '00
    "builtin $FcnApply                $$_null   2\n" +
    "builtin $FcnConstructor          $$_null  -1\n" +
    "builtin $IfThenElse              $$_null   3\n" +
    "builtin $NonRecursiveFcnSpec     $$_null   1\n" +
    "builtin $Pair                    $$_null   2\n" +
    "builtin $RcdConstructor          $$_null  -1\n" +
    "builtin $RcdSelect               $$_null   2\n" +
    "builtin $RecursiveFcnSpec        $$_null   1\n" +
    "builtin $Seq                     $$_null  -1\n" +
    "builtin $SetEnumerate            $$_null  -1\n" +
    "builtin $SetOfAll                $$_null  -1\n" +
    "builtin $SetOfFcns               $$_null  -1\n" +
    "builtin $SetOfRcds               $$_null  -1\n" + // Added by DRJ 1 Oct '00
    "builtin $SF                      $$_null   2\n" +
    "builtin $SquareAct               $$_null   2\n" +
    "builtin $SubsetOf                $$_null   1\n" +
    "builtin $TemporalExists          $$_null   1\n" +
    "builtin $TemporalForall          $$_null   1\n" +
    "builtin $TemporalWhile           $$_null   2\n" +
    "builtin $Tuple                   $$_null  -1\n" +
    "builtin $UnboundedChoose         $$_null   1\n" +
    "builtin $UnboundedExists         $$_null   1\n" +
    "builtin $UnboundedForall         $$_null   1\n" +
    "builtin $WF                      $$_null   2\n"   +
    "builtin $Nop                     $$_null   1\n"   +
    "builtin $Qed                     $$_null   0\n"   +
    "builtin $Pfcase                  $$_null   1\n"   +
    "builtin $Have                    $$_null   1\n"   +
    "builtin $Take                    $$_null   1\n"   +
    "builtin $Pick                    $$_null   1\n"   +
    "builtin $Witness                 $$_null   -1\n"  +

    /***********************************************************************
    * $Suffices added by LL 16 Feb 2009.                                   *
    ***********************************************************************/
    "builtin $Suffices                $$_null   1\n"
  ;

  private static Errors errors;
  private static java.io.Reader input;

  public static void displayDefinitions() {
    ToolIO.out.println( defaultConfig );
  }

  public static void load(Errors errs) throws AbortException {
    /***********************************************************************
    * Called from drivers/SANY.java                                        *
    ***********************************************************************/
    Configuration Parser;
    try {
      errors = errs;
      File source = new File( "config.src" );
      String origin;

      if ( source.exists() ) {
//      java.io.OutputStream output;
        input = new java.io.FileReader( source );
        origin = " from local config.src file.";
      } else {
        input = new java.io.StringReader( defaultConfig );
        origin = " from defaults.";
      }
      Parser = new Configuration( input );

      try {
        Parser.ConfigurationUnit();
//      Operators.printTable();
      } catch (ParseException e) {
        errors.addAbort(Location.nullLoc,"\nConfiguration Parser:  Encountered errors during parse.  "
                        + e.getMessage(),true );
      }

    } catch (java.io.FileNotFoundException e) {
      errors.addAbort(Location.nullLoc,"File not found.\n" + e,true);
    }
  }

  final public void ConfigurationUnit() throws ParseException, AbortException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
      case SYNONYM:
      case BUILTIN:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      OpDefinition();
    }
  }

  final public void OpDefinition() throws ParseException, AbortException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      jj_consume_token(OPERATOR);
      t = jj_consume_token(OPID);

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        OpBody(t.image);
        break;
      case NOTOP:
        OpNull(t.image);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case SYNONYM:
      OpSynonym();
      break;
    case BUILTIN:
      OpBuiltin();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OpBody(String s) throws ParseException {
 Token t;
 int kind, assoc;
 int low, high;
    t = jj_consume_token(NUMBER);
                low = Integer.parseInt( t.image );
    t = jj_consume_token(NUMBER);
                high = Integer.parseInt( t.image );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTASSOC:
      jj_consume_token(LEFTASSOC);
                   assoc = Operators.assocLeft;
      break;
    case RIGHTASSOC:
      jj_consume_token(RIGHTASSOC);
                    assoc = Operators.assocRight;
      break;
    case NOASSOC:
      jj_consume_token(NOASSOC);
                 assoc = Operators.assocNone;
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INFIX:
      jj_consume_token(INFIX);
               kind = Operators.infix;
      break;
    case PREFIX:
      jj_consume_token(PREFIX);
                kind = Operators.prefix;
      break;
    case POSTFIX:
      jj_consume_token(POSTFIX);
                 kind = Operators.postfix;
      break;
    case NFIX:
      jj_consume_token(NFIX);
              kind = Operators.nfix;
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPID:
      t = jj_consume_token(OPID);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
   Operator op;
   if ( t == null ) {
     op = new Operator( UniqueString.uniqueStringOf(s), low, high, assoc, kind );
   } else {
     op = new Operator( UniqueString.uniqueStringOf(t.image), low, high, assoc, kind );
   }
   Operators.addOperator( UniqueString.uniqueStringOf(s), op );
  }

  final public void OpSynonym() throws ParseException {
  Token t1, t2;
    jj_consume_token(SYNONYM);
    t1 = jj_consume_token(OPID);
    t2 = jj_consume_token(OPID);
    Operators.addSynonym( UniqueString.uniqueStringOf(t1.image),
                          UniqueString.uniqueStringOf(t2.image) );
  }

  final public void OpNull(String s) throws ParseException {
    Token t;
    jj_consume_token(NOTOP);
  }

  final public void OpBuiltin() throws ParseException, AbortException {
  Token t;
  String external, internal;
  UniqueString us;
    jj_consume_token(BUILTIN);
    t = jj_consume_token(OPID);
    external = t.image;
    us = UniqueString.uniqueStringOf( external );
    t = jj_consume_token(RESTRICTED);
    internal = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INFIX:
      jj_consume_token(INFIX);
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 2,
                        new FormalParamNode[2], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
      break;
    case PREFIX:
      jj_consume_token(PREFIX);
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 1,
                        new FormalParamNode[1], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
      break;
    case POSTFIX:
      jj_consume_token(POSTFIX);
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 1,
                        new FormalParamNode[1], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
      break;
    case CONSTANT:
      jj_consume_token(CONSTANT);
      Context.addGlobalSymbol(us, new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, 0,
                        new FormalParamNode[0], false, null, null, null, new SyntaxTreeNode(us)),
                        errors);
      break;
    case NUMBER:
      t = jj_consume_token(NUMBER);
      int n = Integer.parseInt( t.image );
      FormalParamNode fpn[] = null;
      if ( n != -1 ) fpn = new FormalParamNode[ n ];
      Context.addGlobalSymbol(us,
                        new OpDefNode(us, tla2sany.semantic.ASTConstants.BuiltInKind, n,
                                      fpn, false, null, null, null, new SyntaxTreeNode(us)),
                                      errors);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  public ConfigurationTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[7];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x44100,0x402000,0x44100,0x38000,0x1e00,0x200000,0x400e80,};
   }

  public Configuration(java.io.InputStream stream) {
     this(stream, null);
  }
  public Configuration(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ConfigurationTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  public Configuration(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConfigurationTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  public Configuration(ConfigurationTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  public void ReInit(ConfigurationTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 7; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[24];
    for (int i = 0; i < 24; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 7; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 24; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
